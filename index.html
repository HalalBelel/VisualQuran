<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Quranic Verse SD Prompt Generator</title>
  <style>
    /* Minimal styling for demonstration */
    body { font-family: Arial, sans-serif; background: #f0f4f8; margin: 0; padding: 20px; }
    .container { max-width: 960px; margin: 0 auto; background: #fff; padding: 20px; border-radius: 8px; }
    h1, h2 { text-align: center; margin-bottom: 10px; }
    form { display: flex; flex-wrap: wrap; gap: 10px; justify-content: space-around; margin-bottom: 20px; }
    form > div { flex: 1 1 200px; min-width: 200px; }
    select, button { padding: 8px; border-radius: 4px; }
    .output { background: #f7f7f7; padding: 15px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 20px; max-height: 300px; overflow: auto; white-space: pre-wrap; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Quranic Verse SD Prompt Generator</h1>
    <p>Enter the verse details below.</p>
    
    <form id="promptForm">
      <div>
        <label for="surahSelect">Select Surah:</label>
        <select id="surahSelect"></select>
      </div>
      <div>
        <label for="verseSelect">Select Ayah:</label>
        <select id="verseSelect"></select>
      </div>
      <div>
        <label for="batchSelect">Select Consecutive Verses:</label>
        <select id="batchSelect">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
        </select>
      </div>
      <div style="flex-basis:100%; text-align:center;">
        <button type="submit">Generate Prompts</button>
      </div>
    </form>
    
    <h2>Raw Output</h2>
    <div id="rawOutput" class="output"></div>
    
    <h2>Reviewed Output</h2>
    <div id="reviewedOutput" class="output"></div>
    
    <h2>Verified Output</h2>
    <div id="verifiedOutput" class="output"></div>
    
    <h2>Generated Images</h2>
    <div id="imageOutput"></div>
    
    <pre id="debugOutput"></pre>
  </div>
  
  <script>
    // Simple helper to pad numbers
    function pad(num, size) {
      return num.toString().padStart(size, '0');
    }

    // A custom delimiter for the prefill naming
    const DELIMITER = " ||| ";

    // A function to ensure each prompt line has the code + delimiter
    function forcePrefillNaming(text, startSurah, startVerse, batch) {
      const paragraphs = text.split("\n\n").filter(p => p.trim() !== "");
      let results = [];
      for (let i = 0; i < batch; i++) {
        const code = pad(startSurah, 3) + pad(startVerse + i, 3) + DELIMITER;
        let content = (i < paragraphs.length) ? paragraphs[i].trim() : "";
        // If content has the delimiter, remove that prefix
        const idx = content.indexOf(DELIMITER);
        if (idx !== -1) {
          content = content.substring(idx + DELIMITER.length).trim();
        }
        results.push(code + content);
      }
      return results.join("\n");
    }

    // Global config loaded from a.json
    let config = {};
    // Global surah data loaded from surahnames.json
    let surahData = [];

    // For debugging
    const debug = true;

    // On load, fetch the config and surah data
    fetch("a.json")
      .then(r => r.json())
      .then(data => {
        config = data;
        if (debug) {
          document.getElementById("debugOutput").textContent += "Loaded config:\n" + JSON.stringify(config, null, 2) + "\n";
        }
      })
      .catch(err => {
        console.error("Failed to load config a.json:", err);
        alert("Failed to load configuration (a.json).");
      });

    fetch("surahnames.json")
      .then(r => r.json())
      .then(data => {
        surahData = data;
        // Populate the surahSelect
        const surahSelect = document.getElementById("surahSelect");
        data.forEach(item => {
          const option = document.createElement("option");
          option.value = item["Surah Number"];
          option.text = `${item["Surah Number"]} - ${item["Surah Name"]}`;
          surahSelect.appendChild(option);
        });
        // Set up the verse dropdown for the first surah
        updateVerseDropdown(parseInt(surahSelect.value));
      })
      .catch(err => {
        console.error("Failed to load surahnames.json:", err);
      });

    function updateVerseDropdown(surahNumber) {
      const verseSelect = document.getElementById("verseSelect");
      verseSelect.innerHTML = "";
      const surahItem = surahData.find(item => item["Surah Number"] === surahNumber);
      if (!surahItem) return;
      for (let i = 1; i <= surahItem["Surah Verses"]; i++) {
        const opt = document.createElement("option");
        opt.value = i;
        opt.text = i;
        verseSelect.appendChild(opt);
      }
    }

    document.getElementById("surahSelect").addEventListener("change", function() {
      updateVerseDropdown(parseInt(this.value));
    });

    // This function calls stablediffusion endpoint
    async function sendToStableDiffusion(finalPrompt, negativePrompt) {
      const payload = {
        prompts: [finalPrompt],
        negative_prompt: negativePrompt
      };
      // Make a POST request to /api/stablediffusion
      const response = await fetch("https://visual-quran.vercel.app/api/stablediffusion", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const data = await response.json();
      if (!data.success) {
        console.error("Stability request failed:", data.error);
        return;
      }
      // data.images is array of base64 or image URLs
      const imageContainer = document.getElementById("imageOutput");
      imageContainer.innerHTML = "";
      data.images.forEach(imgUrl => {
        const img = document.createElement("img");
        img.src = imgUrl;
        img.style.maxWidth = "300px";
        imageContainer.appendChild(img);
      });
    }

    // The verification step (the minimal version)
    async function verifyPrompt() {
      // We'll send only the REVIEW_INSTRUCTIONS
      if (!config.REVIEW_INSTRUCTIONS || !config.MODEL_NAME) {
        return "";
      }
      const maxTokens = config.MAX_TOKENS_MULTIPLIER * 1 + config.MAX_TOKENS_OVERHEAD;
      const payload = {
        model: config.MODEL_NAME,
        max_tokens: maxTokens,
        system: config.VERIFICATION_SYSTEM_ROLE || "",
        messages: [
          { role: "user", content: config.REVIEW_INSTRUCTIONS }
        ]
      };
      if (debug) {
        document.getElementById("debugOutput").textContent += "Verification payload:\n" + JSON.stringify(payload, null, 2) + "\n";
      }
      const res = await fetch(config.VERCEL_PROXY_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const data = await res.json();
      if (!data.content) {
        throw new Error("No content in verification response");
      }
      return Array.isArray(data.content)
        ? data.content.map(item => item.text).join("\n\n")
        : data.content;
    }

    document.getElementById("promptForm").addEventListener("submit", async function(e) {
      e.preventDefault();
      
      const surahNum = parseInt(document.getElementById("surahSelect").value);
      const verseNum = parseInt(document.getElementById("verseSelect").value);
      const batch = parseInt(document.getElementById("batchSelect").value);
      
      // Basic validation
      if (isNaN(surahNum) || isNaN(verseNum) || isNaN(batch)) {
        alert("Please select valid surah/verse/batch.");
        return;
      }

      // Build the user instruction
      if (!config.USER_INSTRUCTION_TEMPLATE || !config.PREFILL_TEMPLATE) {
        alert("Config not fully loaded. Please try again.");
        return;
      }

      const expectedPrefill = config.PREFILL_TEMPLATE
        .replace("{SURAH_PADDED}", pad(surahNum, 3))
        .replace("{VERSE_PADDED}", pad(verseNum, 3));

      let userInstr = config.USER_INSTRUCTION_TEMPLATE
        .replace("{BATCH}", batch)
        .replace("{SURAH}", surahNum)
        .replace("{VERSE}", verseNum)
        .replace("{PREFILL}", expectedPrefill);

      // Prepend the common system role
      const newUserInstruction = (config.COMMON_SYSTEM_ROLE || "") + "\n" + userInstr;

      // Build the payload for the generation
      const maxTokens = batch * config.MAX_TOKENS_MULTIPLIER + config.MAX_TOKENS_OVERHEAD;
      const generationPayload = {
        model: config.MODEL_NAME,
        max_tokens: maxTokens,
        system: config.SYSTEM_ROLE || "",
        messages: [
          { role: "user", content: newUserInstruction },
          { role: "assistant", content: expectedPrefill }
        ]
      };

      document.getElementById("rawOutput").textContent = "Generating prompts...";
      document.getElementById("reviewedOutput").textContent = "";
      document.getElementById("verifiedOutput").textContent = "";

      try {
        // Call the generation
        const genRes = await fetch(config.VERCEL_PROXY_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(generationPayload)
        });
        const genData = await genRes.json();
        if (!genData.content) {
          throw new Error("No content in generation response");
        }
        // Combine if it's array
        let rawText = Array.isArray(genData.content)
          ? genData.content.map(x => x.text).join("\n\n")
          : genData.content;

        document.getElementById("rawOutput").textContent = rawText;

        // Next, call review
        const reviewText = await verifyPrompt();
        document.getElementById("reviewedOutput").textContent = reviewText;

        // Decide final text
        let finalReviewedText;
        const trimmedReview = reviewText.trim();
        if (trimmedReview === "Review Passed" || trimmedReview === "No Previous Prompts Found") {
          finalReviewedText = rawText;
        } else if (trimmedReview === "Connection Error: Please regenerate prompt") {
          document.getElementById("verifiedOutput").textContent = "Connection Error: Please regenerate prompt";
          return;
        } else if (trimmedReview !== "") {
          finalReviewedText = reviewText;
        } else {
          finalReviewedText = rawText;
        }

        // Force prefill naming
        const finalNumbered = forcePrefillNaming(finalReviewedText, surahNum, verseNum, batch);

        // We no longer append negative words to the prompt. 
        // Instead, we build a negativePromptString from config and pass it separately.
        const negativePromptString = []
          .concat(config.FORBIDDEN_EVIL_WORDS, config.FORBIDDEN_NEUTRAL_WORDS, config.FORBIDDEN_SPIRITUAL_WORDS)
          .join(", ");

        // Our final "verified" text is just finalNumbered
        document.getElementById("verifiedOutput").textContent = finalNumbered;

        // Check for forbidden words in finalNumbered
        if (containsForbiddenWords(finalNumbered)) {
          const found = getForbiddenWords(finalNumbered);
          document.getElementById("verifiedOutput").textContent =
            "Sorry forbidden words (" + found.join(", ") + ") were found, please click generate prompt again and report to info@onewordquran.com";
          return;
        }

        // Send finalNumbered + negativePromptString to stablediffusion
        await sendToStableDiffusion(finalNumbered, negativePromptString);

      } catch (err) {
        console.error("Error:", err);
        document.getElementById("rawOutput").textContent = "Error generating prompts.";
      }
    });
  </script>
</body>
</html>
